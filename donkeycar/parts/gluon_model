import re
import json
import os
import mxnet as mx
import numpy as np
from mxnet.gluon.data.dataloader import DataLoader
from PIL import Image
from mxnet import nd, sym, autograd, gluon
from mxnet.ndarray import NDArray
from mxnet.symbol import Symbol
from donkeycar import util
from multiprocessing import cpu_count
import random


class GluonCategorical(gluon.nn.HybridBlock):
    def __init__(self, number_classes = 15):
        self.num_classes = number_classes

        with self.name_scope():
            self.base = gluon.nn.HybridSequential()
            with self.base.name_scope():
                self.base.add(gluon.nn.Conv2D(channels=24, kernel_size=5, strides=(2, 2), activation='relu'))
                self.base.add(gluon.nn.Conv2D(channels=32, kernel_size=5, strides=(2, 2), activation='relu'))
                self.base.add(gluon.nn.Conv2D(channels=64, kernel_size=5, strides=(2, 2), activation='relu'))
                self.base.add(gluon.nn.Conv2D(channels=64, kernel_size=3, strides=(2, 2), activation='relu'))
                self.base.add(gluon.nn.Conv2D(channels=64, kernel_size=3, strides=(1, 1), activation='relu'))

                self.base.add(gluon.nn.Flatten())
                self.base.add(gluon.nn.Dense(100, activation='relu'))
                self.base.add(gluon.nn.Dropout(.1))
                self.base.add(gluon.nn.Dense(50, activation='relu'))
                self.base.add(gluon.nn.Dropout(.1))
            self.create_output()

    def create_output(self):
        self.angle_output = gluon.nn.Dense(self.num_classes)
        self.throttle_output = gluon.nn.Dense(1, activation='relu')

    def hybrid_forward(self, F, x, *args, **kwargs):
        """
        Defines the handling on the input data and the output
        :param nd or sym F:
        :param NDArray or Symbol x:
        :return: List of sym
        """
        x = self.base(x)
        return [self.angle_output(x), self.throttle_output(x)]

    def run(self, img_arr):
        """
        Takes in the Numpy array of the output (the image) and predicts the angle and throttle
        :param img_arr: The numpy array of the image in the format (Height, Width, Channel)
        :return: Angle and throttle as floats
        """

        img_arr = format_img_arr(img_arr.astype('float32'))
        img_arr = np.expand_dims(img_arr, axis=0)
        img_arr = nd.array(img_arr, self.ctx)
        output = self(img_arr)
        angle_output = linear_unbin(output[0][0].asnumpy())
        return angle_output, output[1][0].asscalar()

class ResGluonCategorical(GluonCategorical):
    def __init__(self, ctx):
        super(ResGluonCategorical, self).__init__(ctx)

    def create_model(self):
        with self.name_scope():
            self.base = gluon.model_zoo.vision.resnet18_v2(pretrained=True, ctx=self.ctx).features
            self.create_output()

    def collect_params(self, select=None):
        params = gluon.ParameterDict()
        params.update(self.angle_output)
        params.update(self.throttle_output)
        return params


def format_img_arr(img_arr):
    """
    Formats the PyCamera's Numpy image data and into an ND array to feed through the NN.
    :param numpy.array img_arr: A Numpy array of the form (Height, Width, Channel)
    :return: The data and label in ND Array format, with data being the form (BCHW)
    """
    height_crop = int(img_arr.shape[0] / 3)
    img_arr = img_arr[height_crop:]
    img_arr = np.transpose(img_arr, axes=(2, 0, 1))
    return img_arr


def linear_unbin(arr):
    b = np.argmax(arr)
    a = b * (2 / (len(arr)-1)) - 1
    return a